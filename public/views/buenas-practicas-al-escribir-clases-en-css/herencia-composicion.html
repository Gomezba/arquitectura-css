<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&amp;display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../../css/prism-dracrula.css">
    <link rel="stylesheet" href="../../../dev/css/main.css">
    <title>plantilla</title>
    <script src="../../js/app.js" type="module" defer> </script>
  </head>
  <body class="layout">
    <div class="container-hamburger"><img class="hamburger" id="hamburger" src="../../assets/icons/hamburger.svg" alt="arrow right"></div>
    <header class="page-header" id="pageHeader">
      <nav class="main-nav"><img class="close" id="close" src="../../assets/icons/close.svg" alt="close"><a href="../../../"><img class="logo" src="../../assets/icons/logo.png" alt="logo"></a>
        <section class="container-menu">
          <details class="container-cross-menu">
            <summary class="title-menu">Introducción</summary>
            <ul class="cross-menu">
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/introduccion/css-lenguage.html">CSS es un lenguaje de programación</a></li>
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/introduccion/solucionar-arquitectura-css.html">¿Qué queremos solucionar con arquitectura CSS?</a></li>
            </ul>
          </details>
          <details class="container-cross-menu">
            <summary class="title-menu">Buenas prácticas al escribir clases en CSS</summary>
            <ul class="cross-menu">
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/buenas-practicas-al-escribir-clases-en-css/calidad-css.html">Especificidad de los selectores</a></li>
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/buenas-practicas-al-escribir-clases-en-css/single-responsibility.html">Single responsibility principle en CSS</a></li>
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/buenas-practicas-al-escribir-clases-en-css/herencia-composicion.html">Herencia vs composición en CSS</a></li>
            </ul>
          </details>
          <details class="container-cross-menu">
            <summary class="title-menu">Nomenclatura de tus clases BEM</summary>
            <ul class="cross-menu">
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/nomenclatura-de-tus-clases-bem/mejora-css-bem.html">Mejorar CSS con BEM ventajas e inconvenientes</a></li>
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/nomenclatura-de-tus-clases-bem/mejorar-bem.html">Mejorar lo que no nos gusta con de BEM con utility classes</a></li>
            </ul>
          </details>
          <details class="container-cross-menu">
            <summary class="title-menu">Comparando sistemas de arquitectura</summary>
            <ul class="cross-menu">
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/comparando-sistemas-de-arquitectura/atomit.html">Atomit Design</a></li>
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/comparando-sistemas-de-arquitectura/itcss.html">ITCSS arquitectura apps escalables</a></li>
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/comparando-sistemas-de-arquitectura/lo-mejor.html">Lo mejor de Atomit Design e ITCSS</a></li>
            </ul>
          </details>
          <details class="container-cross-menu">
            <summary class="title-menu">Estilos globales</summary>
            <ul class="cross-menu">
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/estilos-globales/utilizar-variables.html">Cómo utilizar variables, mixins y funciones</a></li>
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/estilos-globales/estilos-globales.html">Base CSS estilos globales</a></li>
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/estilos-globales/estilos-propios.html">Empezando a aplicar estilos propios</a></li>
            </ul>
          </details>
          <details class="container-cross-menu">
            <summary class="title-menu">Modularizar estilos de nuestra app</summary>
            <ul class="cross-menu">
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/modularizar-estilos-de-nuestra-app/primeros-objetos.html">Creando primeros objetos y átomos</a></li>
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/modularizar-estilos-de-nuestra-app/moleculas.html">Clases con significado Moléculas</a></li>
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/modularizar-estilos-de-nuestra-app/componentes-ind.html">Componentes independientes Organismos</a></li>
            </ul>
          </details>
          <details class="container-cross-menu">
            <summary class="title-menu">Arquitectura CSS en app JS</summary>
            <ul class="cross-menu">
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/arquitectura-css-en-app-js/problemas-arq.html">Problemas de arquitectura CSS en app JS</a></li>
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/arquitectura-css-en-app-js/nomenclatura.html">Nomenclatura de clases en componentes JS</a></li>
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/arquitectura-css-en-app-js/atomitcss.html">ATOMITCSS en app JS</a></li>
            </ul>
          </details>
          <details class="container-cross-menu">
            <summary class="title-menu">Arquitectura CSS sin clases</summary>
            <ul class="cross-menu">
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/arquitectura-css-sin-clases/arq-tailwind.html">Arquitectura con Tailwind</a></li>
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/arquitectura-css-sin-clases/arq-styled.html">Arquitectura CSS en JS con Styled Components</a></li>
            </ul>
          </details>
          <details class="container-cross-menu">
            <summary class="title-menu">Cuestiones</summary>
            <ul class="cross-menu">
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/cuestiones/opt-selectores.html">Optimización de selectores</a></li>
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/cuestiones/element-vs.html">Elemento vs layout vs theme</a></li>
              <li class="cross-menu__item"><a class="cross-menu__link" href="../../views/cuestiones/scoped.html">Estilos scoped en componentes y su especificidad</a></li>
            </ul>
          </details>
        </section>
      </nav>
    </header>
    <main class="container main" id="main">
      <h1>Herencia vs composición en CSS</h1>
      <section class="main-info">
        <section class="info">
          <article class="content" id="1">
            <h2>El dilema </h2>
            <p>En el desarrollo frontend, nos enfrentamos a un dilema similar al que se presenta en la programación orientada a objetos: la decisión entre heredar o componer.</p>
            <p>¿Pero por qué surge este problema?</p>
            <p>En primer lugar, el CSS siempre hereda propiedades de manera predeterminada. Por ejemplo, cuando estilizamos un enlace (a), este hereda el font-family del body, entre otras propiedades. Esto es algo inherente al CSS y debemos tenerlo en cuenta. Sin embargo, al organizar nuestras clases, podemos optar por una forma de herencia o por la composición, al igual que en otros lenguajes de programación. Aunque en la práctica, solemos preferir la composición porque simplifica mucho el trabajo.</p>
            <p>Consideremos el siguiente ejemplo:</p>
            <div>
              <pre><code class="language-css">   .btn-primary {
   display: inline-block;
   padding: 0.5rem;

   background: #289f5f;
   color: #fff;
}

.btn-secundary {
   display: inline-block;
   padding: 0.5rem;

   background: #333;
   color: #fff;
}

.btn-danger {
   display: inline-block;
   padding: 0.5rem;

   background: #b00101;
   color: #fff;
}</code></pre>
            </div>
            <p>Tenemos varios botones, pero estamos repitiendo parte del código, como las propiedades <strong>display: inline-block;</strong> y <strong>padding: 0.5rem;</strong>. Además, si queremos agregar un <strong>border-radius</strong>, tendríamos que añadir esa propiedad en todas las clases.</p>
          </article>
          <article class="content" id="2">
            <h2>Extend SASS </h2>
            <p>Una solución al problema mencionado anteriormente es utilizar <code>@extend</code> de <strong>SASS</strong> utilizando el place holder (%) para evitar que al transpilar el SCSS a CSS no genere la clase de la cual estamos heredando.</p>
            <div>
              <pre><code class="language-scss"> %btn{
   display: inline-block;
   padding: 0.5rem;
}

.btn-primary {
	@extend %btn;   
	background: #289f5f;
	color: #fff;
}

.btn-secundary {
   @extend %btn;
	background: #333;
	color: #fff;
}

.btn-danger {
   @extend %btn;
	background: #b00101;
	color: #fff;
}</code></pre>
            </div>
            <div>
              <p>Al transiplar nuestro SCSS a CSS obtenemos lo siguiente</p>
            </div>
            <div>
              <pre><code class="language-css"> .btn-danger,
.btn-secundary,
.btn-primary{
   display: inline-block;
   padding: 0.5rem;
}

.btn-primary {
	background: #289f5f;
	color: #fff;
}

.btn-secundary {
	background: #333;
	color: #fff;
}

.btn-danger {
	background: #b00101;
	color: #fff;
}         </code></pre>
            </div>
            <p class="ts-1">Como podemos observar aquellas clases donde heredamos, estan agrupadas compartiendo las propiedades que definimos dentro de <code>%btn</code>.</p>
            <p>Hasta este punto, parece que hemos solucionado el problema de repetir propiedades, pero esto depende del contexto. Si utilizamos la herencia en SCSS en un escenario donde los elementos no tienen relación entre sí, podemos enfrentarnos a un nuevo problema.</p>
            <p>Veamos el siguiente ejemplo</p>
            <div>
              <pre><code class="language-scss">   %justified{
   display: flex;
   justify-content: space-between;
}

.hero{
   @extend %justified;
   background-color: #289f5f;
   color: #fff;
}

.footer{
   @extend %justified;
   background-color: #333;
   color: #fff;    
}

.section{
   @extend %justified;
   background-color: #fff;
   color: #333;    
}</code></pre>
            </div>
            <div>
              <p>Transpilación a CSS </p>
            </div>
            <div>
              <pre><code class="language-css"> .hero,
.footer,
.section{
   display: flex;
   justify-content: space-between;
}

.hero{
   background-color: #289f5f;
   color: #fff;
}

.footer{
   background-color: #333;
   color: #fff;    
}

.section{
   background-color: #fff;
   color: #333;    
}   </code></pre>
            </div>
            <div>
              <p>El problema surge cuando estos elementos no tienen relación entre sí. Al heredar propiedades como display: flex; y justify-content: space-between;, estamos alineando los elementos en la misma dirección, cuando en realidad cada uno podría necesitar una disposición diferente.</p>
            </div>
            <p>Una solución podria ser un mixin de SASS.</p>
          </article>
          <article class="content" id="3">
            <h2>Mixin SCSS</h2>
            <p>Un mixin nos acerca más al concepto de composición, pero es importante entender sus peculiaridades, ya que podría parecer que estamos volviendo al problema inicial de repetir propiedades.</p>
            <div>
              <pre><code class="language-scss">@mixin justify{
   display: flex;
   justify-content: space-between;
}

.hero{
   @include justify;
   background-color: #289f5f;
   color: #fff;
}

.footer{
   @include justify;
   background-color: #333;
   color: #fff;    
}

.section{
   @include justify;
   background-color: #fff;
   color: #333;    
}    </code></pre>
            </div>
            <div>
              <p>Transpilación a CSS </p>
            </div>
            <div>
              <pre><code class="language-css"> .hero{
   display: flex;
   justify-content: space-between;
   background-color: #289f5f;
   color: #fff;
}

.footer{
   display: flex;
   justify-content: space-between;
   background-color: #333;
   color: #fff;    
}

.section{
   display: flex;
   justify-content: space-between;
   background-color: #fff;
   color: #333;    
}          </code></pre>
            </div>
            <p class="ts-1"> A primera vista, parece que estamos duplicando código al copiar y pegar las propiedades del mixin en todas las clases. Sin embargo, lo que realmente estamos haciendo es generar clases independientes, componiendo estilos, aunque con cierta repetición.</p>
            <p>En este punto, podría parecer que no hemos resuelto el problema y que seguimos repitiendo propiedades. Pero recordemos que al usar un mixin, estamos componiendo, y estos pueden recibir parámetros. Veamos el siguiente ejemplo.</p>
            <div>
              <pre><code class="language-scss">/* Queremos que el parámetro vertical-align sea center por defecto*/
@mixin justify($vertical-align: center){
   display: flex;
   justify-content: space-between;
   align-items: $vertical-align;
}

.hero{
   @include justify;
   background-color: #289f5f;
   color: #fff;
}

/* Es más flexible porque podemos cambiar el valor para elementos en particular */
.footer{
   @include justify($vertical-align: flex-start);
   background-color: #333;
   color: #fff;    
}

.section{
   @include justify;
   background-color: #fff;
   color: #333;    
}</code></pre>
            </div>
            <div>
              <p>Transpilación a CSS</p>
            </div>
            <div>
              <pre><code class="language-css"> .hero{
   display: flex;
   justify-content: space-between;
   align-items: center;
   background-color: #289f5f;
   color: #fff;
}

.footer{
   display: flex;
   justify-content: space-between;
   align-items: flex-start;
   background-color: #333;
   color: #fff;    
}

.section{
   display: flex;
   justify-content: space-between;
   align-items: center;
   background-color: #fff;
   color: #333;    
}</code></pre>
            </div>
            <div>
              <p>Al agregar un parámetro a un mixin, ganamos más flexibilidad, ya que podemos definir ciertos estilos con valores específicos según nuestras necesidades.</p>
            </div>
            <p class="ts-1">Sin embargo, con gran poder viene una gran responsabilidad. No debemos caer en la tentación de crear mixins con demasiados parámetros, ya que esto podría llevarnos de nuevo a aplicar propiedades de manera redundante. Es importante ser cuidadosos.</p>
            <p>En resumen, los mixins son más versátiles que el uso de @extend, pero es crucial utilizarlos con moderación y únicamente en patrones que se repitan con frecuencia y tengan un propósito claro.</p>
          </article>
          <article class="content" id="4">
            <h2>Composición en clases separadas </h2>
            <p>La mejor opción para compartir propiedades entre clases, y la que debería ser nuestra elección predeterminada, es componer utilizando clases separadas. </p>
            <div>
              <pre><code class="language-css"> .btn{
   display: inline-block;
   padding: 0.5rem;
}

.btn-primary {
	background: #289f5f;
	color: #fff;
}

.btn-secundary {
	background: #333;
	color: #fff;
}

.btn-danger {
	background: #b00101;
	color: #fff;
}</code></pre>
            </div>
            <div>
              <p>Lo que hacemos es poner las clases en el html, teniendo una clase padre por así decirlo (btn), y una clase secundaria que es la que se encarga de agregar el estilo contextual.</p>
            </div>
            <div>
              <pre><code class="language-html"> &lt;a class="btn btn-primary" href="/buy"&gt;Comprar&lt;/a&gt;</code></pre>
            </div>
            <div>
              <p>Esta es una estrategia muy efectiva para mantener el CSS simple y semántico, especialmente si no deseas depender de preprocesadores. Al usar clases compuestas como btn btn-primary, garantizas que el estilo base y el contextual estén vinculados de manera coherente. Además, esto facilita la comprensión del código por parte de otros desarrolladores, ya que la relación entre las clases es clara y explícita.</p>
            </div>
          </article>
        </section>
        <nav class="container-submenu" id="submenu"><img class="arrow" id="arrow" src="../../assets/icons/arrow-back.svg" alt="arrow back" />
          <ul class="submenu">
            <li class="submenu__item"><a class="submenu__link" href="#1">El Dilema</a></li>
          </ul>
          <ul class="submenu">
            <li class="submenu__item"><a class="submenu__link" href="#2">Extend SASS</a></li>
          </ul>
          <ul class="submenu">
            <li class="submenu__item"><a class="submenu__link" href="#3">Mixin SCSS</a></li>
          </ul>
          <ul class="submenu">
            <li class="submenu__item"><a class="submenu__link" href="#4">Composición en clases separadas</a></li>
          </ul>
        </nav>
      </section>
    </main>
    <script src="../../js/prism-whitespace.js"></script>
  </body>
</html>